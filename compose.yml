name: mediaserver
services:
  jellyfin:
    image: jellyfin/jellyfin:latest
    container_name: jellyfin
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
      # Reverse-proxy ready (optional labels for later)
      - JELLYFIN_PublishedServerUrl=${HOST_LAN}
    volumes:
      - /opt/mediaserver/jellyfin/config:/config
      - /opt/mediaserver/jellyfin/cache:/cache
      - /mnt/storage/data/media:/media
    ports:
      - "8096:8096"    # HTTP
      # - "8920:8920"  # HTTPS (enable if you terminate TLS here)
      # DLNA/UPnP optional:
      # - "1900:1900/udp"
      # - "7359:7359/udp"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.jellyfin.rule=Host(`jellyfin.w0lverine.uk`)"
      - "traefik.http.routers.jellyfin.entrypoints=websecure"
      - "traefik.http.routers.jellyfin.tls.certresolver=cloudflare"
      - "traefik.http.routers.jellyfin.service=jellyfin"
      - "traefik.http.services.jellyfin.loadbalancer.server.port=8096"
      - "traefik.http.routers.jellyfin.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    devices:
      - /dev/dri:/dev/dri
    group_add:
      - "993"
      - "44"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8096/health"]
      interval: 30s
      timeout: 5s
      retries: 5

  plex:
    image: plexinc/pms-docker:public
    container_name: plex
    network_mode: "host"  # Plex works best on host network; avoids port juggling
    environment:
      - TZ=Europe/London                # <-- set your timezone
      # Run the official image as the same host user/group for correct file perms
      - PLEX_UID=${PUID}
      - PLEX_GID=${PGID}
      - UMASK=002
      # Optional: claim token to (re)claim the server after auth resets
      # Get one from https://plex.tv/claim while logged in (2FA enabled)
      # Tip: set `PLEX_CLAIM=claim-xxxx` in `.env`, then restart just the plex service
      - PLEX_CLAIM=${PLEX_CLAIM:-}
      # Force clients (esp. tvOS/web) to prefer the local endpoints
      # Include secure plex.direct for cert pinning and plain HTTP as fallback on LAN
      - ADVERTISE_IP=https://10-0-0-100.9cc05cc3c9c14a059b2a0222e067e786.plex.direct:32400,http://10.0.0.100:32400
      # (Removed ADVERTISE_IP; Plex will publish validated plex.direct URLs automatically)
    volumes:
      - /opt/mediaserver/plex/config:/config     # <-- change to your preferred config path
      - /mnt/storage/data/media:/media                # <-- root of your media library (or split by type)
      # Optional: dedicate a fast transcode scratch dir (SSD/tmpfs)
      - /opt/mediaserver/plex/transcode:/transcode
    devices:
      - /dev/dri:/dev/dri               # <-- enables Intel Quick Sync (iGPU) via VAAPI
    # Improves device access for some hosts; harmless otherwise
    group_add:
      - "993"
      - "44"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS http://127.0.0.1:32400/identity || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 40s

  overseerr:
    image: lscr.io/linuxserver/overseerr:latest
    container_name: overseerr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      # Optional: if you run through a reverse proxy at a subpath, set this
      # - URL_BASE=/overseerr
    volumes:
      - /opt/mediaserver/overseerr:/config
    ports:
      - "5155:5055"        # host:container (avoid clash with jellyseerr)
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.overseerr.rule=Host(`overseerr.w0lverine.uk`)"
      - "traefik.http.routers.overseerr.entrypoints=websecure"
      - "traefik.http.routers.overseerr.tls.certresolver=cloudflare"
      - "traefik.http.routers.overseerr.service=overseerr"
      - "traefik.http.services.overseerr.loadbalancer.server.port=5055"
      - "traefik.http.routers.overseerr.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
    networks:
      - default
      - web
    restart: unless-stopped
    extra_hosts:
      - "host.docker.internal:host-gateway"  # <-- map this name to the Docker host
    depends_on:
      # not strictly required, but if you want the UI to see *arr* immediately:
      - sonarr
      - radarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5055/api/v1/status"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 30s

  sabnzbd:
    image: lscr.io/linuxserver/sabnzbd:latest
    container_name: sabnzbd
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/sabnzbd:/config
      - /mnt/storage/data/:/data
    ports:
      - "8080:8080"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.sabnzbd.rule=Host(`sabnzbd.w0lverine.uk`)"
      - "traefik.http.routers.sabnzbd.entrypoints=websecure"
      - "traefik.http.routers.sabnzbd.tls.certresolver=cloudflare"
      - "traefik.http.routers.sabnzbd.service=sabnzbd"
      - "traefik.http.services.sabnzbd.loadbalancer.server.port=8080"
      - "traefik.http.routers.sabnzbd.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api?mode=version"]
      interval: 30s
      timeout: 5s
      retries: 10

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/prowlarr:/config
      - /mnt/storage/data:/data
    ports:
      - "9696:9696"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prowlarr.rule=Host(`prowlarr.w0lverine.uk`)"
      - "traefik.http.routers.prowlarr.entrypoints=websecure"
      - "traefik.http.routers.prowlarr.tls.certresolver=cloudflare"
      - "traefik.http.routers.prowlarr.service=prowlarr"
      - "traefik.http.services.prowlarr.loadbalancer.server.port=9696"
      - "traefik.http.routers.prowlarr.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9696/"]
      interval: 30s
      timeout: 5s
      retries: 10

  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    container_name: sonarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/sonarr:/config
      - /mnt/storage/data:/data
      - /mnt/storage/data/media:/media
    ports:
      - "8989:8989"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.sonarr.rule=Host(`sonarr.w0lverine.uk`)"
      - "traefik.http.routers.sonarr.entrypoints=websecure"
      - "traefik.http.routers.sonarr.tls.certresolver=cloudflare"
      - "traefik.http.routers.sonarr.service=sonarr"
      - "traefik.http.services.sonarr.loadbalancer.server.port=8989"
      - "traefik.http.routers.sonarr.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    depends_on:
      - sabnzbd
      - prowlarr
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS 'http://localhost:8989/api/v3/system/status?apikey=${HOMEPAGE_VAR_SONARR_API_KEY}' >/dev/null"]
      interval: 30s
      timeout: 5s
      retries: 10

  radarr:
    image: lscr.io/linuxserver/radarr:latest
    container_name: radarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - UMASK=${UMASK}
    volumes:
      - /opt/mediaserver/radarr:/config
      - /mnt/storage/data:/data
      - /mnt/storage/data/media:/media
    ports:
      - "7878:7878"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.radarr.rule=Host(`radarr.w0lverine.uk`)"
      - "traefik.http.routers.radarr.entrypoints=websecure"
      - "traefik.http.routers.radarr.tls.certresolver=cloudflare"
      - "traefik.http.routers.radarr.service=radarr"
      - "traefik.http.services.radarr.loadbalancer.server.port=7878"
      - "traefik.http.routers.radarr.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    depends_on:
      - sabnzbd
      - prowlarr
    healthcheck:
      test: ["CMD", "bash", "-O", "extglob", "-c", "curl -fsS 'http://localhost:7878/api/v3/system/status?apikey=${HOMEPAGE_VAR_RADARR_API_KEY}' >/dev/null"]
      interval: 30s
      timeout: 5s
      retries: 10

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: bazarr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/bazarr:/config
      - /mnt/storage/data/media:/media
    ports:
      - "6767:6767"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.bazarr.rule=Host(`bazarr.w0lverine.uk`)"
      - "traefik.http.routers.bazarr.entrypoints=websecure"
      - "traefik.http.routers.bazarr.tls.certresolver=cloudflare"
      - "traefik.http.routers.bazarr.service=bazarr"
      - "traefik.http.services.bazarr.loadbalancer.server.port=6767"
      - "traefik.http.routers.bazarr.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    depends_on:
      - sonarr
      - radarr
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6767/system/status"]
      interval: 30s
      timeout: 5s
      retries: 10

  recyclarr:
    image: ghcr.io/recyclarr/recyclarr:latest
    container_name: recyclarr
    user: "${PUID}:${PGID}"
    environment:
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/recyclarr:/config
    # No ports; run via cron-like schedule below using restart policy + command
    command: ["sync"]
    restart: "no"  # We'll run on-demand with: docker compose run --rm recyclarr

  jellyseerr:
    image: fallenbagel/jellyseerr:latest
    container_name: jellyseerr
    environment:
      - LOG_LEVEL=info
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/jellyseerr:/app/config
    ports:
      - "5055:5055"
    restart: unless-stopped
    depends_on:
      - jellyfin

  tautulli:
    image: lscr.io/linuxserver/tautulli:latest
    container_name: tautulli
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /opt/mediaserver/tautulli:/config
    ports:
      - "8181:8181"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tautulli.rule=Host(`tautulli.w0lverine.uk`)"
      - "traefik.http.routers.tautulli.entrypoints=websecure"
      - "traefik.http.routers.tautulli.tls.certresolver=cloudflare"
      - "traefik.http.routers.tautulli.service=tautulli"
      - "traefik.http.services.tautulli.loadbalancer.server.port=8181"
      - "traefik.http.routers.tautulli.middlewares=security-headers@file,rate-limit@file"
      - "traefik.docker.network=web"
      - "com.centurylinklabs.watchtower.enable=true"
    networks:
      - default
      - web
    restart: unless-stopped
    depends_on:
      - plex
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8181/" ]
      interval: 30s
      timeout: 5s
      retries: 10

  jellyplex-watched:
    image: luigi311/jellyplex-watched:latest
    container_name: jellyplex-watched
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      # App config
      - DRYRUN=False
      - DEBUG_LEVEL=DEBUG
      - RUN_ONLY_ONCE=False
      - SLEEP_DURATION=300
      # Persist logs/marks to mounted path
      - LOG_FILE=/config/log.log
      - MARK_FILE=/config/mark.log
      # Plex (host network container) — access via host gateway
      - PLEX_BASEURL=http://host.docker.internal:32400
      - PLEX_TOKEN=${HOMEPAGE_VAR_PLEX_TOKEN}
      # Jellyfin (same compose network) — access via service name
      - JELLYFIN_BASEURL=http://jellyfin:8096
      - JELLYFIN_TOKEN=${JELLYFIN_TOKEN}
      # Only Plex <-> Jellyfin syncing enabled by default
      - SYNC_FROM_PLEX_TO_PLEX=False
      - SYNC_FROM_PLEX_TO_EMBY=False
      - SYNC_FROM_JELLYFIN_TO_EMBY=False
      - SYNC_FROM_EMBY_TO_PLEX=False
      - SYNC_FROM_EMBY_TO_JELLYFIN=False
      - SYNC_FROM_EMBY_TO_EMBY=False
    volumes:
      - /opt/mediaserver/jellyplex-watched:/config
    extra_hosts:
      - "host.docker.internal:host-gateway"
    restart: unless-stopped
    depends_on:
      - plex
      - jellyfin
    labels:
      - "com.centurylinklabs.watchtower.enable=true"

  fail2ban:
    image: crazymax/fail2ban:latest
    container_name: fail2ban
    network_mode: "host"          # manage iptables in the host namespace
    cap_add:
      - NET_ADMIN
      - NET_RAW
    environment:
      - TZ=${TZ}
      - F2B_LOG_TARGET=STDOUT
      - F2B_LOG_LEVEL=INFO
    volumes:
      # Fail2ban config (filters, jails, state)
      - ./security/fail2ban:/data
      # Map the current Plex log file to a space-free path inside the container
      - /opt/mediaserver/plex/config/Library/Application Support/Plex Media Server/Logs/Plex Media Server.log:/var/log/plexms/plexms.log:ro
    restart: unless-stopped

  watchtower:
    image: containrrr/watchtower
    container_name: watchtower
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - TZ=Europe/London
      - WATCHTOWER_NOTIFICATIONS=shoutrrr
      - WATCHTOWER_NOTIFICATION_URL=discord://JEFJGh8jQNjrH6V8t6IsvE41olupuu2XPMPfp2t7uKvZ4LvbhTw5VcbRJcj2kRiSrgVp@1411600579880550460
      - WATCHTOWER_NOTIFICATIONS_LEVEL=info        # startup + updates + warnings/errors
      - WATCHTOWER_NOTIFICATION_REPORT=true        # send a summary every run (even 0 updates)
      - WATCHTOWER_NOTIFICATION_TITLE_TAG=watchtower@${HOSTNAME}
      - WATCHTOWER_NO_STARTUP_MESSAGE=true         # suppress the initial "updates on <id>" line
      # Always send a readable summary with names (even when 0 updates)
      - 'WATCHTOWER_NOTIFICATION_TEMPLATE={{- if .Report -}}{{- with .Report -}}{{len .Scanned}} scanned, {{len .Updated}} updated, {{len .Failed}} failed{{- if .Updated}}{{println}}Updated: {{- range $$i, $$u := .Updated}}{{- if $$i}}, {{end -}}{{$$u.Name}}{{- end}}{{- end -}}{{- if .Failed}}{{println}}Failed: {{- range $$i, $$f := .Failed}}{{- if $$i}}, {{end -}}{{$$f.Name}}{{- end}}{{- end -}}{{- if .Skipped}}{{println}}Skipped: {{- range $$i, $$s := .Skipped}}{{- if $$i}}, {{end -}}{{$$s.Name}}{{- end}}{{- end -}}{{- end -}}{{- end -}}'
      - WATCHTOWER_INCLUDE_RESTARTING=true         # scan restarting containers too
      - WATCHTOWER_INCLUDE_STOPPED=true            # scan stopped containers for image updates
    command: >
      --cleanup                    
      --rolling-restart            
      --stop-timeout 60s
      --schedule "0 0 4 * * *"     
    restart: unless-stopped

  backup:
    image: ghcr.io/borgmatic-collective/borgmatic:1.8.12
    container_name: mediaserver-backup
    restart: unless-stopped
    environment:
      TZ: "Europe/London"
      BORG_REPOSITORY: "/mnt/backup/mediaserver"   # 👈 backups stored here
      BORG_PASSPHRASE: "${BORG_PASSPHRASE:?set in .env}"
    volumes:
      # Borgmatic config & hooks
      - ./backup/config:/etc/borgmatic:ro
      # Provide cron schedule to the container
      - ./backup/config/crontab.txt:/etc/crontabs/root:ro
      # Borg runtime state
      - borg-cache:/root/.cache/borg
      - borg-config:/root/.config/borg

      # Sources to back up (read-only)
      - .:/backup/mediaserver:ro

      # Mount backup target from host
      - /mnt/backup:/mnt/backup

    read_only: true
    tmpfs:
      - /tmp:rw,exec
      - /run:rw,exec

  rclone_backup:
    image: alpine:3.20
    container_name: rclone_backup
    restart: unless-stopped
    environment:
      - TZ=${TZ}
      - RCLONE_CONFIG=/etc/rclone/rclone.conf
    volumes:
      - /mnt/backup/mediaserver:/data:ro
      - /opt/mediaserver/backup/rclone:/config/rclone
      - ./backup/rclone/crontab.txt:/etc/crontabs/root:ro
    command: >
      sh -c "apk add --no-cache rclone tzdata >/dev/null \
      && mkdir -p /etc/rclone /root/.config/rclone \
      && if [ -f /config/rclone/rclone.conf ]; then cp /config/rclone/rclone.conf /etc/rclone/rclone.conf && cp /config/rclone/rclone.conf /root/.config/rclone/rclone.conf; else echo 'rclone.conf missing; run rclone config'; fi \
      && crond -f -d 8"

volumes:
  borg-cache:
  borg-config:


 
networks:
  default:
    name: media_net
    external: true
    # Keeps LAN/Tailscale exposure simple via host IP bindings above

  web:
    external: true

# Note:
# /mnt/storage/data is an existing NFS mount on the host. We bind-mount that into containers.
# That keeps permissions consistent with PUID/PGID and avoids Docker's NFS volume caveats.
